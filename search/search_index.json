{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"R-Type \ud83d\udc7e R-Type is a game inspired by the original r-type game . Installation You can play on Linux and Windows . First, clone the project: git clone git@github.com:EpitechPromo2026/B-CPP-500-LYN-5-1-rtype-jacques.marques.git Requirement To run this game on Linux, you must have gcc , g++ , cmake , mesa-utils , build-essential , libgl1-mesa-dev , freeglut3-dev installed You can install these packages using your preferred package manager. For example, on Debian or Ubuntu, you can use the following command: sudo apt install gcc g++ cmake mesa-utils build-essential libgl1-mesa-dev freeglut3-dev Once these packages are installed, you should be able to build and run your game without any problems. Then to install the necessary dependencies, use the following command: ./install_requirement.sh Compilation To compile the R-Type project, execute the following command: ./compile.sh Authors Jacques Matthis Antoine Louis Project Documentation For detailed project documentation, including developer documentation, architectural diagrams, main system overviews, and tutorials, please visit our Documentation Website . This website provides a practical, well-structured resource for new developers looking to understand our project. a Network Protocol Documentation To understand the communication protocol in our network game, please refer to the RFC Document . This document describes the various commands and packets exchanged between the server and the client. It's designed to enable anyone to develop a new client for our server by reading the protocol documentation. We appreciate your interest in R-Type and welcome you to our project. If you have any questions or need assistance, please don't hesitate to contact our team. Thank you for considering R-Type!","title":"Getting started"},{"location":"#r-type","text":"R-Type is a game inspired by the original r-type game .","title":"R-Type \ud83d\udc7e"},{"location":"#installation","text":"You can play on Linux and Windows . First, clone the project: git clone git@github.com:EpitechPromo2026/B-CPP-500-LYN-5-1-rtype-jacques.marques.git","title":"Installation"},{"location":"#requirement","text":"To run this game on Linux, you must have gcc , g++ , cmake , mesa-utils , build-essential , libgl1-mesa-dev , freeglut3-dev installed You can install these packages using your preferred package manager. For example, on Debian or Ubuntu, you can use the following command: sudo apt install gcc g++ cmake mesa-utils build-essential libgl1-mesa-dev freeglut3-dev Once these packages are installed, you should be able to build and run your game without any problems. Then to install the necessary dependencies, use the following command: ./install_requirement.sh","title":"Requirement"},{"location":"#compilation","text":"To compile the R-Type project, execute the following command: ./compile.sh","title":"Compilation"},{"location":"#authors","text":"Jacques Matthis Antoine Louis","title":"Authors"},{"location":"#project-documentation","text":"For detailed project documentation, including developer documentation, architectural diagrams, main system overviews, and tutorials, please visit our Documentation Website . This website provides a practical, well-structured resource for new developers looking to understand our project. a","title":"Project Documentation"},{"location":"#network-protocol-documentation","text":"To understand the communication protocol in our network game, please refer to the RFC Document . This document describes the various commands and packets exchanged between the server and the client. It's designed to enable anyone to develop a new client for our server by reading the protocol documentation. We appreciate your interest in R-Type and welcome you to our project. If you have any questions or need assistance, please don't hesitate to contact our team. Thank you for considering R-Type!","title":"Network Protocol Documentation"},{"location":"about/","text":"About Introduction This project, R-Type, is one of the main project of our third year at Epitech. Team Members Lous de Caumont Matthis Broncheton Jacques Marques Antoine Dufour Dependencies This project was built using the following technologies: C++ : The main programming language used for development. SFML : A simple, fast, cross-platform multimedia library used to provide easy access to system components. Standardese : A nextgen Doxygen-alternative C++ documentation generator tool used for generating documentation. Conan : A portable package manager, intended for C and C++ developers, but it is able to manage builds from source, dependencies, and precompiled binaries for any language. Mkdocs : A fast, simple and downright gorgeous static site generator that's geared towards building project documentation. Thanks Thanks for checking our project !","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#introduction","text":"This project, R-Type, is one of the main project of our third year at Epitech.","title":"Introduction"},{"location":"about/#team-members","text":"Lous de Caumont Matthis Broncheton Jacques Marques Antoine Dufour","title":"Team Members"},{"location":"about/#dependencies","text":"This project was built using the following technologies: C++ : The main programming language used for development. SFML : A simple, fast, cross-platform multimedia library used to provide easy access to system components. Standardese : A nextgen Doxygen-alternative C++ documentation generator tool used for generating documentation. Conan : A portable package manager, intended for C and C++ developers, but it is able to manage builds from source, dependencies, and precompiled binaries for any language. Mkdocs : A fast, simple and downright gorgeous static site generator that's geared towards building project documentation.","title":"Dependencies"},{"location":"about/#thanks","text":"Thanks for checking our project !","title":"Thanks"},{"location":"characterGuide/","text":"Character Guide Introduction This section provides a guide to the characters in R-Type. Character 1 This is a spaceship Character 2 This is a spaceship","title":"Character Guide"},{"location":"characterGuide/#character-guide","text":"","title":"Character Guide"},{"location":"characterGuide/#introduction","text":"This section provides a guide to the characters in R-Type.","title":"Introduction"},{"location":"characterGuide/#character-1","text":"This is a spaceship","title":"Character 1"},{"location":"characterGuide/#character-2","text":"This is a spaceship","title":"Character 2"},{"location":"devDoc/","text":"Here is our documentation Dev documentation .","title":"Dev documentation"},{"location":"diagram/","text":"Architectural Diagrams Overview Here is an example of a typical \"layer/subsystem\" view of video games:","title":"Diagram"},{"location":"diagram/#architectural-diagrams","text":"","title":"Architectural Diagrams"},{"location":"diagram/#overview","text":"Here is an example of a typical \"layer/subsystem\" view of video games:","title":"Overview"},{"location":"gameMechanics/","text":"Game Mechanics Introduction This section provides an overview of the game mechanics for R-Type. Gameplay R-Type is a side-scrolling shooter game in which you pilot a spaceship to face waves of alien enemies. The main objective is to survive these attacks while progressing through the levels. The gameplay is characterized by spaceship movement, projectile shooting, and power-up enhancements. Controls Controls in R-Type depend on the platform you are playing on, but here is a typical controller configuration: Ship Movement: Use directional arrows. Primary Fire: Press the fire button to launch projectiles against enemies. Power-ups: Some items or enemies drop power-ups. Collect them to upgrade your ship's abilities, such as more powerful shots or protective shields. Use of Power-ups: Some power-ups are activated automatically, while others may require a specific action, such as pressing a dedicated button. Scoring The scoring system in R-Type is based on the number of enemies destroyed, bonuses collected, and the duration of survival. Each defeated enemy earns a certain number of points, and power-ups can also influence your score. Players often aim to achieve a high score to rank among the best.","title":"Game Mechanics"},{"location":"gameMechanics/#game-mechanics","text":"","title":"Game Mechanics"},{"location":"gameMechanics/#introduction","text":"This section provides an overview of the game mechanics for R-Type.","title":"Introduction"},{"location":"gameMechanics/#gameplay","text":"R-Type is a side-scrolling shooter game in which you pilot a spaceship to face waves of alien enemies. The main objective is to survive these attacks while progressing through the levels. The gameplay is characterized by spaceship movement, projectile shooting, and power-up enhancements.","title":"Gameplay"},{"location":"gameMechanics/#controls","text":"Controls in R-Type depend on the platform you are playing on, but here is a typical controller configuration: Ship Movement: Use directional arrows. Primary Fire: Press the fire button to launch projectiles against enemies. Power-ups: Some items or enemies drop power-ups. Collect them to upgrade your ship's abilities, such as more powerful shots or protective shields. Use of Power-ups: Some power-ups are activated automatically, while others may require a specific action, such as pressing a dedicated button.","title":"Controls"},{"location":"gameMechanics/#scoring","text":"The scoring system in R-Type is based on the number of enemies destroyed, bonuses collected, and the duration of survival. Each defeated enemy earns a certain number of points, and power-ups can also influence your score. Players often aim to achieve a high score to rank among the best.","title":"Scoring"},{"location":"levelGuide/","text":"Level Guide Introduction This section provides a guide to the levels in R-Type. Level 1 In construction ! Level 2 In construction !","title":"Level Guide"},{"location":"levelGuide/#level-guide","text":"","title":"Level Guide"},{"location":"levelGuide/#introduction","text":"This section provides a guide to the levels in R-Type.","title":"Introduction"},{"location":"levelGuide/#level-1","text":"In construction !","title":"Level 1"},{"location":"levelGuide/#level-2","text":"In construction !","title":"Level 2"},{"location":"protocolDoc/","text":"Network Protocol for Game Client-Server Communication Status: Informational Created by: Matthis, Jacques, Antoine, Louis Version: 1.0 Date: October 10, 2023 Abstract This document presents a client-server communication protocol for the game \"R-Type,\" utilizing a combination of UDP and TCP. The protocol facilitates the exchange of structured data between clients and the server through a custom serializer/deserializer. 1. Introduction The primary objective of this protocol is to streamline communication between a video game client and server while employing a custom serializer/deserializer. It is versatile, supporting both UDP for low-latency communication and TCP for reliability. 2. Message Header All messages exchanged between the client and server adhere to a common structure. The message header encompasses the following elements: - Message Type: Binary - Message Size: 64 bits - Session Identifier: Connection ID 3. UDP Communication 3.1. Advantages and Limitations UDP-based communication is reserved for low-latency operations, including real-time player position updates. 3.2. UDP Message Format UDP messages conform to the common message header structure, followed by data specific to the message type. 3.3. Server-Side UDP Data Reception and Deserialization The server-side UDP data reception and deserialization process involves listening for incoming data from connected clients. The server uses a while loop to manage incoming data over the UDP protocol. 3.3.1. Data Reception via UDP The server continuously listens for incoming data from UDP clients using the following code: while (this->_run) { int bytes_received = recvfrom(this->_socket, buffer, BUFFER_STREAM_UDP, 0, (struct sockaddr *)&from, (socklen_t *)&from_length); if (bytes_received == SOCKET_ERROR) { #ifdef _WIN32 printf(\"recvfrom() failed with error %d\\n\", WSAGetLastError()); #else perror(\"recvfrom() failed\"); #endif return; } // ... } 3.3.2. Data Deserialization for UDP The received data is then processed and deserialized using the ReaderStream and Serializer classes, similar to the TCP deserialization process. Key deserialization steps are as follows: oengine::opack::Serializer serializer; _stream->allocation_reader_stream(this->_buffer, this->_bytes_received); if (_stream->_completed) { serializer.data(_stream->data()); _request_name = serializer >> _request_name; _id = serializer >> _id; //printf(\"Request Name: %s, Id: %d\\n\", request_name.c_str(), id); serializer.clear(); _stream->clear(); } 4. TCP Communication 4.1. Advantages and Limitations TCP-based communication is employed for operations necessitating reliability, such as authentication and transactions. 4.2. TCP Message Format TCP messages adhere to the common message header structure, followed by data specific to the message type. TCP communication guarantees the preservation of message order. 4.3. Server-Side TCP Data Reception and Deserialization The server-side TCP data reception and deserialization process involves listening for incoming data from connected clients. The server uses a while loop to manage incoming data over the TCP protocol. 4.3.1. Data Reception via TCP The server continuously receives data via a TCP connection using the following code: while (this->connected) { try { if ((r = recv(this->_csocket, buffer, BUFFER_STREAM_TCP, 0)) == 0) { this->close_client(); break; } _stream->allocation_reader_stream(buffer, r); _stream->dump(); if (_stream->_completed) { // Deserialize the data serializer.data(_stream->data()); request_name = serializer >> request_name; id = serializer >> id; printf(\"Request Name: %s, Id: %d\\n\", request_name.c_str(), id); // Further processing of the deserialized data can be performed here serializer.clear(); _stream->clear(); } } catch (std::exception e) { this->close_client(); } } 4.3.2. Data Deserialization for TCP The received data is then processed and deserialized using the ReaderStream and Serializer classes. Key deserialization steps are as follows: // Deserialize the data serializer.data(_stream->data()); request_name = serializer >> request_name; id = serializer >> id; // Further processing of the deserialized data can be performed here 5. Serializer/Deserializer The custom serializer/deserializer, which is utilized to convert data to bytes and vice versa, is elaborated upon in the associated source code. 6. Security The protocol includes a connection-level authentication system for UDP communication. 7. Client-Side Data Serialization and Transmission This section provides an overview of how data is serialized and transmitted from the client to the server using both UDP and TCP. Examples of data serialization and transmission are presented for each protocol. 7.1. Serialization for UDP: Data serialization for UDP enables clients to prepare structured data for transmission. The following code snippet illustrates how data can be serialized: std::string requestName(\"OnConnection\"); int id = 10; oengine::opack::Serializer serializer(requestName.size() + 8); serializer << requestName; serializer << id; oengine::opack::byte *serializedData = serializer.data(); size_t sizeDataSerialized = serializer.count_data(requestData); 7.2. Sending Serialized Data over UDP: After data serialization, clients can transmit the serialized data over the UDP protocol to the server. The following code demonstrates this process: int _socketClient = socket(AF_INET, SOCK_DGRAM, 0); if (_socketClient < 0) { perror(\"socket error\"); return false; }; memset(&_serverAddr, 0, sizeof(_serverAddr)); _serverAddr.sin_family = AF_INET; _serverAddr.sin_port = htons(_serverPort); if (inet_pton(AF_INET, _serverIP.c_str(), &_serverAddr.sin_addr) <= 0) { perror(\"inet_pton error\"); return false; } ssize_t bytesSent = sendto(_socketClient, data, size, 0, (struct sockaddr*)&_serverAddr, sizeof(_serverAddr)); 7.3. Serialization for TCP: For data transmission over TCP, the client must first serialize the data. The code snippet below illustrates how data can be serialized for TCP transmission: std::string requestName(\"OnConnection\"); int id = 10; oengine::opack::Serializer serializer(requestName.size() + 8); serializer << requestName; serializer << id; oengine::opack::byte *requestData = serializer.data(); size_t sizeData = serializer.count_data(requestData); 7.4. Sending Serialized Data over TCP: Once the data is properly serialized, clients establish a TCP connection with the server and transmit the data. The following code demonstrates this process: if ((socketClient = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(\"socket error\"); exit(O_EXIT_FAILURE); } struct sockaddr_in addressClient; addressClient.sin_family = AF_INET; addressClient.sin_port = htons(serverPort); if (inet_pton(AF_INET, serverIP.c_str(), &addressClient.sin_addr) <= 0) { perror(\"inet_pton error\"); exit(O_EXIT_FAILURE); } if (connect(socketClient, (struct sockaddr *)&addressClient, sizeof(addressClient)) < 0) { perror(\"connect error\"); exit(O_EXIT_FAILURE); } std::cout << \"Connected to the server\" << std::endl; write(socketClient, requestData, sizeData); This client-side data serialization and transmission process is essential for sending structured information to the server, enabling the client to communicate effectively within the game network. 8. Conclusion This client-server communication protocol, which combines UDP and TCP, serves as a robust foundation for communication within a video game environment. Specific details, including message types, supported operations, and security measures, should be tailored to suit the game's unique requirements. The protocol facilitates efficient data exchange between clients and the server, contributing to a seamless gaming experience.","title":"Protocol documentation"},{"location":"protocolDoc/#network-protocol-for-game-client-server-communication","text":"Status: Informational Created by: Matthis, Jacques, Antoine, Louis Version: 1.0 Date: October 10, 2023","title":"Network Protocol for Game Client-Server Communication"},{"location":"protocolDoc/#abstract","text":"This document presents a client-server communication protocol for the game \"R-Type,\" utilizing a combination of UDP and TCP. The protocol facilitates the exchange of structured data between clients and the server through a custom serializer/deserializer.","title":"Abstract"},{"location":"protocolDoc/#1-introduction","text":"The primary objective of this protocol is to streamline communication between a video game client and server while employing a custom serializer/deserializer. It is versatile, supporting both UDP for low-latency communication and TCP for reliability.","title":"1. Introduction"},{"location":"protocolDoc/#2-message-header","text":"All messages exchanged between the client and server adhere to a common structure. The message header encompasses the following elements: - Message Type: Binary - Message Size: 64 bits - Session Identifier: Connection ID","title":"2. Message Header"},{"location":"protocolDoc/#3-udp-communication","text":"","title":"3. UDP Communication"},{"location":"protocolDoc/#31-advantages-and-limitations","text":"UDP-based communication is reserved for low-latency operations, including real-time player position updates.","title":"3.1. Advantages and Limitations"},{"location":"protocolDoc/#32-udp-message-format","text":"UDP messages conform to the common message header structure, followed by data specific to the message type.","title":"3.2. UDP Message Format"},{"location":"protocolDoc/#33-server-side-udp-data-reception-and-deserialization","text":"The server-side UDP data reception and deserialization process involves listening for incoming data from connected clients. The server uses a while loop to manage incoming data over the UDP protocol.","title":"3.3. Server-Side UDP Data Reception and Deserialization"},{"location":"protocolDoc/#331-data-reception-via-udp","text":"The server continuously listens for incoming data from UDP clients using the following code: while (this->_run) { int bytes_received = recvfrom(this->_socket, buffer, BUFFER_STREAM_UDP, 0, (struct sockaddr *)&from, (socklen_t *)&from_length); if (bytes_received == SOCKET_ERROR) { #ifdef _WIN32 printf(\"recvfrom() failed with error %d\\n\", WSAGetLastError()); #else perror(\"recvfrom() failed\"); #endif return; } // ... }","title":"3.3.1. Data Reception via UDP"},{"location":"protocolDoc/#332-data-deserialization-for-udp","text":"The received data is then processed and deserialized using the ReaderStream and Serializer classes, similar to the TCP deserialization process. Key deserialization steps are as follows: oengine::opack::Serializer serializer; _stream->allocation_reader_stream(this->_buffer, this->_bytes_received); if (_stream->_completed) { serializer.data(_stream->data()); _request_name = serializer >> _request_name; _id = serializer >> _id; //printf(\"Request Name: %s, Id: %d\\n\", request_name.c_str(), id); serializer.clear(); _stream->clear(); }","title":"3.3.2. Data Deserialization for UDP"},{"location":"protocolDoc/#4-tcp-communication","text":"","title":"4. TCP Communication"},{"location":"protocolDoc/#41-advantages-and-limitations","text":"TCP-based communication is employed for operations necessitating reliability, such as authentication and transactions.","title":"4.1. Advantages and Limitations"},{"location":"protocolDoc/#42-tcp-message-format","text":"TCP messages adhere to the common message header structure, followed by data specific to the message type. TCP communication guarantees the preservation of message order.","title":"4.2. TCP Message Format"},{"location":"protocolDoc/#43-server-side-tcp-data-reception-and-deserialization","text":"The server-side TCP data reception and deserialization process involves listening for incoming data from connected clients. The server uses a while loop to manage incoming data over the TCP protocol.","title":"4.3. Server-Side TCP Data Reception and Deserialization"},{"location":"protocolDoc/#431-data-reception-via-tcp","text":"The server continuously receives data via a TCP connection using the following code: while (this->connected) { try { if ((r = recv(this->_csocket, buffer, BUFFER_STREAM_TCP, 0)) == 0) { this->close_client(); break; } _stream->allocation_reader_stream(buffer, r); _stream->dump(); if (_stream->_completed) { // Deserialize the data serializer.data(_stream->data()); request_name = serializer >> request_name; id = serializer >> id; printf(\"Request Name: %s, Id: %d\\n\", request_name.c_str(), id); // Further processing of the deserialized data can be performed here serializer.clear(); _stream->clear(); } } catch (std::exception e) { this->close_client(); } }","title":"4.3.1. Data Reception via TCP"},{"location":"protocolDoc/#432-data-deserialization-for-tcp","text":"The received data is then processed and deserialized using the ReaderStream and Serializer classes. Key deserialization steps are as follows: // Deserialize the data serializer.data(_stream->data()); request_name = serializer >> request_name; id = serializer >> id; // Further processing of the deserialized data can be performed here","title":"4.3.2. Data Deserialization for TCP"},{"location":"protocolDoc/#5-serializerdeserializer","text":"The custom serializer/deserializer, which is utilized to convert data to bytes and vice versa, is elaborated upon in the associated source code.","title":"5. Serializer/Deserializer"},{"location":"protocolDoc/#6-security","text":"The protocol includes a connection-level authentication system for UDP communication.","title":"6. Security"},{"location":"protocolDoc/#7-client-side-data-serialization-and-transmission","text":"This section provides an overview of how data is serialized and transmitted from the client to the server using both UDP and TCP. Examples of data serialization and transmission are presented for each protocol.","title":"7. Client-Side Data Serialization and Transmission"},{"location":"protocolDoc/#71-serialization-for-udp","text":"Data serialization for UDP enables clients to prepare structured data for transmission. The following code snippet illustrates how data can be serialized: std::string requestName(\"OnConnection\"); int id = 10; oengine::opack::Serializer serializer(requestName.size() + 8); serializer << requestName; serializer << id; oengine::opack::byte *serializedData = serializer.data(); size_t sizeDataSerialized = serializer.count_data(requestData);","title":"7.1. Serialization for UDP:"},{"location":"protocolDoc/#72-sending-serialized-data-over-udp","text":"After data serialization, clients can transmit the serialized data over the UDP protocol to the server. The following code demonstrates this process: int _socketClient = socket(AF_INET, SOCK_DGRAM, 0); if (_socketClient < 0) { perror(\"socket error\"); return false; }; memset(&_serverAddr, 0, sizeof(_serverAddr)); _serverAddr.sin_family = AF_INET; _serverAddr.sin_port = htons(_serverPort); if (inet_pton(AF_INET, _serverIP.c_str(), &_serverAddr.sin_addr) <= 0) { perror(\"inet_pton error\"); return false; } ssize_t bytesSent = sendto(_socketClient, data, size, 0, (struct sockaddr*)&_serverAddr, sizeof(_serverAddr));","title":"7.2. Sending Serialized Data over UDP:"},{"location":"protocolDoc/#73-serialization-for-tcp","text":"For data transmission over TCP, the client must first serialize the data. The code snippet below illustrates how data can be serialized for TCP transmission: std::string requestName(\"OnConnection\"); int id = 10; oengine::opack::Serializer serializer(requestName.size() + 8); serializer << requestName; serializer << id; oengine::opack::byte *requestData = serializer.data(); size_t sizeData = serializer.count_data(requestData);","title":"7.3. Serialization for TCP:"},{"location":"protocolDoc/#74-sending-serialized-data-over-tcp","text":"Once the data is properly serialized, clients establish a TCP connection with the server and transmit the data. The following code demonstrates this process: if ((socketClient = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(\"socket error\"); exit(O_EXIT_FAILURE); } struct sockaddr_in addressClient; addressClient.sin_family = AF_INET; addressClient.sin_port = htons(serverPort); if (inet_pton(AF_INET, serverIP.c_str(), &addressClient.sin_addr) <= 0) { perror(\"inet_pton error\"); exit(O_EXIT_FAILURE); } if (connect(socketClient, (struct sockaddr *)&addressClient, sizeof(addressClient)) < 0) { perror(\"connect error\"); exit(O_EXIT_FAILURE); } std::cout << \"Connected to the server\" << std::endl; write(socketClient, requestData, sizeData); This client-side data serialization and transmission process is essential for sending structured information to the server, enabling the client to communicate effectively within the game network.","title":"7.4. Sending Serialized Data over TCP:"},{"location":"protocolDoc/#8-conclusion","text":"This client-server communication protocol, which combines UDP and TCP, serves as a robust foundation for communication within a video game environment. Specific details, including message types, supported operations, and security measures, should be tailored to suit the game's unique requirements. The protocol facilitates efficient data exchange between clients and the server, contributing to a seamless gaming experience.","title":"8. Conclusion"},{"location":"tipsAndTricks/","text":"Tips and Tricks Introduction This section provides some useful tips and tricks for playing R-Type. Tip 1 // Tip 2","title":"Tips and Tricks"},{"location":"tipsAndTricks/#tips-and-tricks","text":"","title":"Tips and Tricks"},{"location":"tipsAndTricks/#introduction","text":"This section provides some useful tips and tricks for playing R-Type.","title":"Introduction"},{"location":"tipsAndTricks/#tip-1","text":"//","title":"Tip 1"},{"location":"tipsAndTricks/#tip-2","text":"","title":"Tip 2"}]}